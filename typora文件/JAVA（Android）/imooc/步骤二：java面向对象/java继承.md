+ java只能单继承，一个子类只能有一个父类
+ ... extends ...
+ 可以用super.的方法 访问父类的属性和方法

## 方法重载

+ 同一个类中
+ 方法名相同 参数列表不同
+ 方法返回值 访问修饰符任意
+ 与方法参数名无关

## 方法重写

+ 有继承关系的子类中
+ 方法名、参数个数，顺序，和父类相同
+ 访问修饰符限定范围大于等于父类
+ 与方法的参数名无关
+ 另：子类中也可以重写父类中的属性，直接改 
+ 返回值 可以不同！！与父类向下兼容即可。

## 访问修饰符

+ private：只允许本类中访问
+ 不加修饰符：同一个包下都能使用，跨包不可以
+ protect：跨包的非子类不能使用，其他都可以
+ public：任意位置访问
+ ![image-20210505194137102](C:\Users\15200\AppData\Roaming\Typora\typora-user-images\image-20210505194137102.png)

## 访问修饰符对方法重写的影响

继承时，允许发生改变，但是访问范围需要大于等于父类的访问范围。

**父类的构造函数，不允许被继承 也不允许被重写，但是不可缺少**

object是顶级父类

子类构造**默认会调用父类的无参构造**，使用super()可以调有参的构造，构造方法调用必须在构造方法里第一句

**子类对象构造时必须调用父类的构造方法**！！！不然会编译错误

## super和this

+ super.可以访问父类的属性和方法
+ this.可以访问当前类的属性和方法
+ super()可以访问父类的构造方法
+ this()可以访问当前类的构造方法
+ super和this调用构造方法都必须放在第一行，所以this调用和super不能同时使用
+ 二者都不能在静态方法中使用

## Object类

存放在java.long包里，系统默认加载这个包

其中的方法有：

+ equals（）
  + **继承自Object类中的equals方法时，比较的是两个引用是否指向同一个对象**
  + 字符串的equals方法重写过了，比较的是字符串里的内容
  + 字符串的==比较的是引用的地址
  +  在重写时，对象之间也能用强制转换，在使用对象操作时，空指针异常要注意
+ toString（）
  + 输出对象名时，默认直接用，输出对象的字符串表示形式时：类型信息+@+地址信息
  + 可以通过重写 改变输出的内容和表现形式。

## final关键字

+ 当一个类不希望有子类继承，前加final关键字，**绝种了**的意思，和public的位置可以互换
+ 如果final+方法，这个方法不允许被重写，可以被使用
+ final修饰方法内局部变量，只要在具体被使用前赋值即可，被赋值就不能修改
+ final修饰方法内成员属性，如果定义时没有赋值，只有构造方法和构造代码块能赋值，其他地方不能赋值
+ final修饰引用数据类型，实例化之后不能进行引用地址的修订，但对象里的属性值可以修改
+ 可以和static一起使用，表示静态的 不允许被修改的成员

## 注解

@Override：**代表java认证的重写父类的方法**，如果父类没有，那就报错了，可以用来检测自己的重写是否合理

可以删，但是不能乱加，称为注解，用来对包、类、属性、方法、局部变量、方法参数等进行说明注释

也有一些运行时注解，会影响程序运行

按运行机制分：

+ 源码注解
+ 编译时注解
+ 运行时注解

按来源分：

+ 来自JDK的注解
+ 来自第三方的注解
+ 我们自己定义的注解



