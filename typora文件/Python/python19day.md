# 内容回顾

软件开发规范

#### 预计

递归函数1天

re模块2天

logging模块+包的导入+带参数的装饰器1-2天

面向对象6天

网络编程4天

并发编程5-6天

数据库5天

# 今日内容

1. 模块和实际工作之间的关系

   + time模块和时间是什么关系?
     + 时间本身和time模块无关，有了time就可以在python中操作时间相关的问题了。
   + re模块和正则表达式的关系
     + 有了re模块就可以在python语言操作使用正则表达式了

2. 正则表达式******

   + 什么是正则表达式：一套匹配字符串的规则

   + 能做什么：

     + 检测一个输入的字符串是否合法
       + 用户输入一个内容的时候，我们要提前做检测
       + 能够提高程序的效率并且减轻服务器的压力
     + 从一个大文件中找到所有符合规则的内容
       + 能够高效的从一大段文字中快速找到符合规则的内容

   + 正则规则

     ![image-20200629110244458](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200629110244458.png)

     + 所有的规则中的字符就可以刚好匹配到字符串中的内容

   + 字符组[]

     + 一个字符组（中括号）只表示一个字符位置
     + [abc]会匹配a或b或c
     + [0-9]、[A-Z]、[a-z]、[a-zA-Z]大小写、
     + [0-9a-zA-Z_]数字字母下划线

   + 元字符

     + 在正则表达式中能过帮我们匹配的内容符号
     + 字符组[]
     + \d=[0-9]     匹配任意一位数字
     + \w=[0-9a-zA-Z_] 匹配数字字母下划线
     + \s=（''|\t|\n）   匹配所有空白（空格、tab、enter）
     + \W 表示非字母数字下划线
     + \D 表示非数字
     + \S 表示非空白
     + . 表示匹配除了换行符之外的所有，前加\会取消意义。
     + [^c] 表示没c的段
     + ^匹配一个字符串的开始
     + $匹配一个字符串的结尾
     + A|B 匹配A或B表达式中的内容，如果A成功了，就不匹配B了，所以两个规则有重叠，把长的放在前面
     + （）约束（|）或描述的范围
       + www\.(baidu|google|taobao)\.com
     + \b匹配边界的字符

   + 记忆元字符

     + \d \w \s \t \n \D \W \S
     + []  [^]
     + ^  $
     + |  ( )

   + 量词（元字符后加量词的格式，约束次数）

     + {n} 表示匹配n次，
     + {n，}表示匹配至少n次
     + {n，m}表示至少匹配n次，至多匹配m次
     + ？表示匹配1次或0次
     + +表示匹配1次或多次
     + *表示匹配0次或多次

   + 整数：`\d+`

   + 小数：`\d+\.\d+`

   + 整数或小数：`\d+(\.\d+)?`

   + 手机号码：1 3-9 11位`^1[3-9]\d{9}$`

   + 贪婪匹配：`\d{3,}6`会在量词允许的范围尽量多匹配

     + 回溯算法

       ![image-20200629120525985](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200629120525985.png)

       `.*?x`表示匹配任意字符任意次数，但一旦遇到x就停

   + 惰性匹配：`\d{3,}?6`会在量词允许的范围尽量少匹配

     + 加一个问号
     + ??时，前面代表0或1次，后面代表惰性，所以匹配0次
     + `.*?x`表示匹配任意字符任意次数，但一旦遇到x就停

   + 转义符\

     + 有特殊意义的字符有时需要转义

   + （?:）不显示括号内容

     + ```python
       ret=re.findall('1(?:\d)(\d)','123') #'3'
       ```

       

3. re模块--regex正则表达式

   ```python
   import re
   ret=re.findall('\d','1231294u921jds')
   print(ret) #['1', '2', '3', '1', '2', '9', '4', '9', '2', '1']
   ret2=re.search('\d+','123928482y87')
   print(ret2) #<_sre.SRE_Match object; span=(0, 9), match='123928482'>
   if ret2:
       print(ret2.group()) #123928482
   ```

   + findall 总是只显示括号里匹配到的内容

     + 还是按照完整的正则匹配
     + re.findall('9(\d)u','1231294u921jds') #['4']
     + 加括号是为了对真正需要的内容进行提取

   + search 

     + 还是按完整的正则进行匹配，显示也显示匹配内容
     + 得到的结果是一个变量
       + 变量.group（）的结果 完全和 变量.group（0）结果一样
       + 变量.group（n）的形式来获取第n个分组中匹配的内容
     + search不需要加括号分组，因为可以向group（）中传参实现。

   + 小爬虫例子

     + https://movie.douban.com/top250?start=0&filter=

     + ```python
       #简单爬虫
       import re
       with open('douban.html',encoding='utf-8')as f:
           content=f.read()
       ret=re.findall('<span class="title">(.*?)</span>(?:\s*<span class="title">.*?</span>)?',content)
       print(ret)
       ```

# 今日总结

正则

+ 字符组元字符
+ 量词
+ 贪婪匹配、惰性匹配
+ 转义符

re模块

+ 如果要查找的内容在一个复杂的环境中
  + 我们要查找的内容没有一个突出的特点，甚至会和不需要的杂乱的数据混合在一起。

什么是爬虫

+ 通过代码获取到一个网页的源码

+ 要的是源码中嵌着的网页上的内容

+ ```python
  #从网页获取源码
  import requests
  ret=requests.get('https://movie.douban.com/top250?start=0&filter=')
  print(ret.content.decode('utf-8'))
  ```

分组和findall现象

+ 为什么要分组？
  + 把想要的内容放分组里

如何取消分组优先

+ 如果在写正则的时候由于不得已的原因，导致不要的内容也得写在分组里
+ (?:) 取消这个分组的优先显示

## 代码总行数2288+37=2325行

